# NestJS 中的动态模块

动态模块(Dynamic Modules)是 NestJS 中一个强大的功能，它允许你在运行时动态配置模块，而不是使用静态的元数据。这使得模块可以根据不同的使用场景提供不同的配置或依赖关系。

## 基本概念

静态模块是在 `@Module()` 装饰器中明确定义其提供者、控制器等的模块。而动态模块则是在运行时通过一个返回模块定义的方法来创建的。

## 为什么需要动态模块

动态模块主要用于：

- 需要根据不同配置创建不同实例的场景
- 需要提供可配置的模块给其他开发者使用
- 需要在运行时决定模块的组成

## 动态模块的结构

一个典型的动态模块由一个静态方法和一个模块类组成：

typescript

```ts
@Module({})
export class ConfigModule {
  static forRoot(options: ConfigOptions): DynamicModule {
    return {
      module: ConfigModule,
      providers: [
        {
          provide: CONFIG_OPTIONS,
          useValue: options,
        },
        ConfigService,
      ],
      exports: [ConfigService],
    };
  }
}
```

## 动态模块的关键部分

1. **静态方法**：通常是 `forRoot()` 或 `register()`，用于接收配置参数
2. **返回的 DynamicModule 对象**：包含：
   - `module`: **模块类本身**
   - `providers`: 要注册的提供者
   - `exports`: 要导出的提供者
   - `imports`: 需要导入的其他模块
   - `controllers`: 控制器

> 注意：return 的module是模块本身

## 使用示例

typescript

```ts
// 定义动态模块
@Module({})
export class DatabaseModule {
  static forRoot(entities = [], options?): DynamicModule {
    const providers = createDatabaseProviders(options, entities);
    return {
      module: DatabaseModule,
      providers: providers,
      exports: providers,
    };
  }
}

// 使用动态模块
@Module({
  imports: [DatabaseModule.forRoot([User])],
})
export class AppModule {}
```

## 常见的动态模块模式

1. **forRoot()**：用于配置模块的全局实例
2. **forFeature()**：用于配置模块的特定功能
3. **register()**：用于注册一次性配置
4. **async register()**：用于异步配置

## 异步配置示例

typescript

```ts
@Module({})
export class ConfigModule {
  static forRootAsync(options: ConfigAsyncOptions): DynamicModule {
    return {
      module: ConfigModule,
      imports: options.imports || [],
      providers: [
        {
          provide: CONFIG_OPTIONS,
          useFactory: options.useFactory,
          inject: options.inject || [],
        },
        ConfigService,
      ],
      exports: [ConfigService],
    };
  }
}
```

动态模块是 NestJS 模块系统的核心特性之一，它使得创建可配置、可重用的模块变得非常简单。许多官方模块(如 TypeORM、JWT、Passport 等)都使用了动态模块模式。