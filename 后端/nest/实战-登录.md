### 密码验证

使用以下工具:

- @nestjs/passport
- passport
- passport-local

passport 是一个身份验证工具，提供多种方式（策略）的身份认证，其中 passport-local 是使用用户名与密码验证；

@nestjs/passport 是 nestjs 封装的 passport



#### 创建 local 策略

```ts
import { Strategy } from 'passport-local';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';
import { AuthService } from '@/auth/auth.service';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy，[Strategy-name]) {
  constructor(private authService: AuthService) {
    // Strategy配置
    super({
      usernameField: 'username',
      passwordField: 'password',
    });
  }

  async validate(username: string, password: string): Promise<any> {
    const user = await this.authService.validateUser(username, password);
    return user;
  }
}

```

LocalStrategy 继承自 PassportStrategy, Strategy 引入自 passport-local，表明使用 local 策略；

LocalStrategy 会自动取 username, password 字段，也可以在 super 中配置取的字段名称；

validate 函数用来编写验证逻辑，return null或者 false表名验证失败，LocalStrategy会抛出401错误；

[Strategy-name] 为可选代表策略名称，不填入时为默认 local

接下来创建 validateUser 函数用来验证身份：

```ts
 async validateUser(
    username: string,
    password: string,
  ): Promise<Record<string, any> | null> {
    const user = await this.userService.findOneUser(username);
    if (user && (await argon2.verify(user.password, password))) return user;
    return null;
  }
```

#### 注册 passport

在 auth.module 中注册 passport:

```ts
import { Module } from '@nestjs/common';
import { UserModule } from 'src/user/user.module';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';
import { PassportModule } from '@nestjs/passport';
import { LocalStrategy } from '@/strategy/local.strategy';

@Module({
  imports: [
    UserModule,
    PassportModule,
  ],
  controllers: [AuthController],
  providers: [AuthService, LocalStrategy],
})
export class AuthModule {}

```

引入 PassportModule 时，nextjs 会将该策略注册至全局，也就是说后面使用 LocalStrategy 时可以直接使用；

providers 将 LocalStrategy 导出；

需要注册多个Strategy时需要进行区分：

```ts
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class LocalAuthGuard extends AuthGuard([Strategy-name]) {}
```

#### 使用

```ts
  @UseGuards(AuthGuard('local')) // 或者 @UseGuards(LocalAuthGuard)
  @Post('login')
  login(@Request() req: { user: UserDto }) {
    return req.user;
  }
```



### jwt 生成

在 auth.service 中使用 @nestjs/jwt 中的 JwtService 生成token

```ts
  // 生成token
  async createJWT(user: { username: string; id: string }): Promise<string> {
    const payload = { username: user.username, sub: user.id };
    const token = await this.jwtService.signAsync(payload);
    return token;
  }
```

当然，前提时需要注册 jwtModule

```ts
auth.module.ts

@Module({
    JwtModule.registerAsync({
      global: true,
      useFactory: () => ({
        secret: process.env[configEnum.JWT_SECRET],
        signOptions: { expiresIn: process.env[configEnum.JWT_EXPIRES_IN] },
      }),
    }),
})
```

之后再 user.controller.ts 使用createJWT并返回token

```ts
 @UseGuards(AuthGuard('local'))
  @Post('login')
  @HttpCode(200)
  async login(@Request() req: { user: UserDto }) {
    const token = await this.authService.createJWT(req.user as any);
    return {
      data: {
        token,
        user: req.user,
      },
    };
  }
```

> **注意**
>
> **在两个模块相互引用时，会出现循环引用的问题，可以使用 forwardRef()  延迟加载模块 解决此问题**



