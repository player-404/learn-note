### 密码验证

使用以下工具:

- @nestjs/passport
- passport
- passport-local

passport 是一个身份验证工具，提供多种方式（策略）的身份认证，其中 passport-local 是使用用户名与密码验证；

@nestjs/passport 是 nestjs 封装的 passport



#### 创建 local 策略

```ts
import { Strategy } from 'passport-local';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';
import { AuthService } from '@/auth/auth.service';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy，[Strategy-name]) {
  constructor(private authService: AuthService) {
    // Strategy配置
    super({
      usernameField: 'username',
      passwordField: 'password',
    });
  }

  async validate(username: string, password: string): Promise<any> {
    const user = await this.authService.validateUser(username, password);
    return user;
  }
}

```

LocalStrategy 继承自 PassportStrategy, Strategy 引入自 passport-local，表明使用 local 策略；

LocalStrategy 会自动取 username, password 字段，也可以在 super 中配置取的字段名称；

validate 函数用来编写验证逻辑，return null或者 false表名验证失败，LocalStrategy会抛出401错误；

[Strategy-name] 为可选代表策略名称，不填入时为默认 local

接下来创建 validateUser 函数用来验证身份：

```ts
 async validateUser(
    username: string,
    password: string,
  ): Promise<Record<string, any> | null> {
    const user = await this.userService.findOneUser(username);
    if (user && (await argon2.verify(user.password, password))) return user;
    return null;
  }
```

#### 注册 passport

在 auth.module 中注册 passport:

```ts
import { Module } from '@nestjs/common';
import { UserModule } from 'src/user/user.module';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';
import { PassportModule } from '@nestjs/passport';
import { LocalStrategy } from '@/strategy/local.strategy';

@Module({
  imports: [
    UserModule,
    PassportModule,
  ],
  controllers: [AuthController],
  providers: [AuthService, LocalStrategy],
})
export class AuthModule {}

```

引入 PassportModule 时，nextjs 会将该策略注册至全局，也就是说后面使用 LocalStrategy 时可以直接使用；

providers 将 LocalStrategy 导出；

需要注册多个Strategy时需要进行区分：

```ts
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class LocalAuthGuard extends AuthGuard([Strategy-name]) {}
```

#### 使用

```ts
  @UseGuards(AuthGuard('local')) // 或者 @UseGuards(LocalAuthGuard)
  @Post('login')
  login(@Request() req: { user: UserDto }) {
    return req.user;
  }
```



### jwt 生成

在 auth.service 中使用 @nestjs/jwt 中的 JwtService 生成token

```ts
  // 生成token
  async createJWT(user: { username: string; id: string }): Promise<string> {
    const payload = { username: user.username, sub: user.id };
    const token = await this.jwtService.signAsync(payload);
    return token;
  }
```

当然，前提时需要注册 jwtModule

```ts
auth.module.ts

@Module({
    JwtModule.registerAsync({
      global: true,
      useFactory: () => ({
        secret: process.env[configEnum.JWT_SECRET],
        signOptions: { expiresIn: process.env[configEnum.JWT_EXPIRES_IN] },
      }),
    }),
})
```

之后再 user.controller.ts 使用createJWT并返回token

```ts
 @UseGuards(AuthGuard('local'))
  @Post('login')
  @HttpCode(200)
  async login(@Request() req: { user: UserDto }) {
    const token = await this.authService.createJWT(req.user as any);
    return {
      data: {
        token,
        user: req.user,
      },
    };
  }
```

> **注意**
>
> **在两个模块相互引用时，会出现循环引用的问题，可以使用 forwardRef()  延迟加载模块 解决此问题**



### passport 默认行为修改

#### 修改默认返回的错误信息

Passport 策略提供了 `handleRequest` 方法，可以拦截验证错误并自定义响应：

```ts
import { ExtractJwt, Strategy } from 'passport-jwt';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private readonly configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get('JWT_SECRET'),
    });
  }

  // 覆盖 handleRequest 方法
  handleRequest(err: any, user: any, info: any, context: any, status: any) {
    if (err || !user) {
      throw new UnauthorizedException('无效的 Token 或 Token 已过期'); // 自定义错误消息
    }
    return user;
  }

  validate(payload: any) {
    return { userId: payload.sub, username: payload.username };
  }
}
```



#### 修改 validate 函数返回数据的存储字段

Passport 策略提供了 `authenticate ` 方法，可以修改数据存储的位置：

```ts
import { Strategy } from 'passport-jwt';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private readonly configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: configService.get('JWT_SECRET'),
    });
  }

  // 覆盖 authenticate 方法，修改数据存储字段
  authenticate(req: any, options?: any) {
    super.authenticate(req, options, (err, user, info) => {
      if (err) return this.error(err);
      if (!user) return this.fail(info);
      
      // 将数据存储到 req.data 而非 req.user
      req.data = user; // 🎯 关键修改
      this.success(user, info);
    });
  }

  validate(payload: any) {
    return { id: payload.sub, username: payload.username }; // 返回的数据会存入 req.data
  }
}
```

或者：通过继承 `AuthGuard` 并覆盖请求处理逻辑

```ts
// src/guards/jwt-auth.guard.ts
import { AuthGuard } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  handleRequest(err: any, user: any, info: any, context: any) {
    const request = context.switchToHttp().getRequest();
    request.data = user; // 🎯 将数据存入 req.data
    return user;
  }
}

// 在 Controller 中使用
@UseGuards(JwtAuthGuard)
@Get('profile')
getProfile(@Request() req) {
  return req.data; // 数据现在在 req.data 中
}
```

