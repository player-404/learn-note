在nestjs中 `@Injectable` 装饰器来实例化 `provider`， 默认的作用域是单例，也就只实例化一次，在别处也使用到时引入这个实例；

nestjs 为  `@Injectable` 提供了以下几种注入作用域：

### 1.  默认作用域 (DEFAULT/SINGLETON)

- **行为**：整个应用程序生命周期内只创建一个实例，单例模式，多处使用时复用这个实例
- **特点**：
  - 所有模块共享同一个实例
  - 高效，因为不需要重复实例化
  - 适合无状态服务

```ts
@Injectable()
export class MyService {} // 默认就是 SINGLETON 作用域
```

这种作用域下的变量时全局共享的，一个变量的改变会直接影响所有使用到该实例的地方

### 2. 请求作用域 (REQUEST)

- **行为**：为每个传入的请求创建一个新实例， 每次请求都会重新实例化一次，各个请求使用的实例的单独的

- **特点**：
  - 请求结束后实例会被垃圾回收
  - 可以访问请求上下文
  - 适合需要请求隔离的场景

```ts
@Injectable({ scope: Scope.REQUEST })
export class MyRequestScopedService {}
```

这种作用域下每个请求都会重新实例化，拥有自己的provider，实例中的数据也是各自独立的

### 3. 瞬态作用域 (TRANSIENT)

- **行为**：每次注入时都创建一个新实例，每次使用到该 provider 时都会重新实例化
- **特点**：
  - 不共享实例
  - 每个消费者获得自己的实例
  - 适合需要完全隔离的场景

```ts
@Injectable({ scope: Scope.TRANSIENT })
export class MyTransientService {}
```

### 作用域继承规则

- 如果一个单例服务注入了一个请求作用域的服务，那么这个单例服务也会隐式变成请求作用域
- 这种"作用域冒泡"机制确保了依赖链的一致性



